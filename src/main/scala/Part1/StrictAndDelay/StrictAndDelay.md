## 正格と遅延
これまでは、単方向リストの純粋関数型のデータ構造について map, filter, foldLeft などリストの演算を実装しながら学んだ。
こうした演算はそれぞれが入力をスキャンし、出力用の新しいリストを生成することをがわかった。

例として、ひと組のトランプから奇数のカードを抜き取り、クイーンを全て返すように言われたとする。
理想は、全てのカードを通しで調べるときに、クイーンと奇数のカードを同時に探したい。奇数のカードを抜き取った後、残りのカードからクイーンを探すよりも、作業を1回で済ませることができ効率的である。

以下のコードが行っているのは、前者の方である。
```scala
// map, filter などの純粋関数を都度実行すると、先頭から全ての値を走査し、新しい List を返す
// 以下の例だと単純な計算だが、3度も走査し、List を生成している
val list: List[Int] = List(1, 2, 3, 4, 5, 6).map(_ + 10).filter(_ % 2 == 0).map(_ * 3)
println(list)  // List(36, 42, 48)
/*
  細かく分けると以下のように中間のリストを生成している
  List(1, 2, 3, 4, 5, 6).map(_ + 10).filter(_ % 2 == 0).map(_ * 3)
  List(11, 12, 13, 14, 15, 16).filter(_ % 2 == 0).map(_ * 3)
  List(12, 14, 16).map(_ * 3)
  List(36, 42, 48)
 */
```
なんとかして、一連の変換を1回の処理にまとめたい。
`map` や `filter` といったループの自動的な融合は、**非正格性** を使って実現できるらしい。（**非正格性 == 遅延性**）

ここでは、**非正格性** がどのようなものか学習し、複数の変換を融合する遅延リスト型を実装する。 

### 正格関数と非正格関数
遅延リストの例をみる前に、基礎の理解する。

#### 正格と非正格とは
非正格性は関数の特性である。非正格関数では、その引数の1つ以上を評価しないという選択が可能。

逆に、**正格関数**では、引数が常に評価される。正格関数はほとんどのプログラミング言語の標準になっている。
ほとんどの言語がサポートしているのは引数が完全に評価されることを期待する関数だけである。
特に明記しない限り、Scala の関数定義は全て正格であると考えて良い。ここまで定義してきた関数は全て正格である。

例
```scala
def square(x: Double): Double = x * x
```
`square` 関数は正格であるため、`square(41.0 + 1.0)` の呼び出しでは、計算済みの `42.0` という値が渡されることになる。
`square(sys.error("Error!!"))` の呼び出しでは、`square` の本体に入る前に `sys.error()` 式が評価されるため、`square` が何かをする前に例外が発生する。

非正確性の概念には馴染みがある。例えば、短絡理論関数 `&&` および `||` が含まれるが、これらは非正格である。
`&&`, `||` は引数を評価しないことを選択できる関数として考えることができる。`&&` 関数は `Boolean` 型の引数を2つ受け取るが、2つ目の引数を評価するのは、1つ目の引数が `true` の場合のみ。
```scala
false && {
  println("評価")
  true
} // 何も出力しない

true || {
  println("評価")
  false
} // 何も出力しない
```

`if` 制御構文も非正格の一例である。

`if` は Scala の言語に組み込まれている構造だが、`Boolean` 型の条件、条件が `true` の場合に返す `A` 型の式、および条件が `false` の場合に返す、`A` 型の式という3つのパラメータを受け取る関数として考えることができる。
関数としての `if` は、引数を全て評価しないため、非正格である。

もっと正確に言うと、実行する分岐を判定するために条件を常に評価するため、条件パラメータについては正格である。分岐については、条件に基づいて評価するため、非正格ということになる。
```scala
if (list.isEmpty) sys.error("評価されました！！！") else list // エラーは評価されていない
```

Scala で非正格関数を記述するには、引数の一部を評価されない状態で受け取る。非正格関数である `if` は以下のようになる。
```scala
def if2[A](cond: Boolean, onTrue: () => A, onFalse: () => A): A =
  if (cond) onTrue() else onFalse()

if2(true, () => println("true!!!"), () => sys.error("false!!!")) // true!!!
```
評価せずに渡したい引数の手前に、`() =>` が付いている。
`() => A`型の値は、0個の引数を取り、`A` を返す関数。評価されない形式の式を一般に **サンク(thunk)** と呼ぶ。
サンクに対しては、式の評価と結果の取得を**強制**することができる。そのためには、`onTrue()` などのように、関数を呼び出してからの引数リストを渡す。
同様に、`if2` の呼び出し元が、明示的に作成する必要もある。そのための構文は、関数リテラル構文の規約に従う。

各非正格パラメータの代わりに引数なしの関数を渡した後、この関数を本体から明示的に呼び出して結果を取得している。これは、よくあるケースのため、より便利な構文が用意されている。
```scala
def if3[A](cond: Boolean, onTrue: => A, onFalse: => A): A =
  if (cond) onTrue else onFalse

if3(true, println("TRUE!!!"), sys.error("FALSE!!!")) // TRUE!!!
```
評価せずに渡したい引数の型の手前に `=>` がある、。この `=>` の付いた引数を評価するために関数本体で特別なことはしなくて良い。識別子を通常通り参照するだけ。

呼び出し元も特別なことはしなくて良い。通常の関数構文を使用できる。

評価されずに関数に渡される引数は、関数の本体内で参照されている場所ごとに1だけ評価される。Scala は引数の評価結果を（デフォルトでは）キャッシュしない。

結果を1回だけ評価したい場合は、val 宣言時に `lazy` キーワードを追加する。`lazy val` 宣言の右辺の評価が最初に参照される時まで先送りされる。
また、その後の参照で評価を繰り返し行うことがないよう、結果がキャッシュされる。Scala の非正格関数は引数を**値渡し**ではなく**名前渡し**で受け取る。
```scala
def notCache(b: Boolean, i: => Int): Int = if (b) i + i else 0

notCache(true, {
  println("Not cache !!!!!")
  100
})
// Not cache !!!!!
// Not cache !!!!!

def cache(b: Boolean, i: => Int): Int = {
  lazy val j = i
  if (b) j + j else 0
}

cache(true, {
  println("Cache !!!!!")
  100
})
// Cache !!!!!
```

